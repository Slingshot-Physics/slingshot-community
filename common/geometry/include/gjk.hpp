#ifndef GJK_HEADER
#define GJK_HEADER

#include "vector3.hpp"
#include "geometry_types.hpp"
#include "support_functions.hpp"
#include "transform.hpp"

typedef geometry::types::minkowskiDiffSimplex_t gjk_simplex_t;
typedef geometry::types::labeledVertex_t gjk_labeledVertex_t;
typedef geometry::types::minkowskiDiffVertex_t gjk_mdVertex_t;
typedef geometry::types::gjkResult_t gjk_result_t;

namespace geometry
{

// A general note - the GJK algorithm calculates minimum-norm points on a
// simplex in Minkowski-difference space. The minimum-norm point is the point
// on the simplex closest to the origin, and also the minimum description
// sub-simplex on the major simplex containing that minimum norm point.
namespace gjk
{
   // Adds a complete MD vertex to a simplex with a maximum of 4 points.
   void addVertexToSimplex(
      const gjk_mdVertex_t & md_vert, gjk_simplex_t & simplex
   );

   // Checks if the test point, vert, is on the current simplex.
   bool pointCoincident(const Vector3 & vert, const gjk_simplex_t & simplex);

   // Returns the point in the simplex with minimum norm to the supplied vector
   // (the point on the simplex closest to the origin) and the barycentric
   // coordinate of the min-norm point.
   geometry::types::pointBaryCoord_t minNormPoint(
      const gjk_simplex_t & simplex
   );

   // Generates a minimum simplex out of the given simplex based on the
   // barycentric coordinates from the minimum-norm point.
   // Non-zero elements of the bary coord correspond to indices for vertices
   // that are on the minimum simplex.
   gjk_simplex_t minSimplex(
      const Vector4 & min_norm_bary, const gjk_simplex_t & simplex
   );

   // Run the GJK algorithm with some shape in each body's body frame.
   // Notation:
   //
   //    `_W` --> global or world coordinates (ENU)
   //    `_A` --> in body A's body frame, with the origin at body A's center of
   //             geometry
   //    `_B` --> in body B's body frame, with the origin at body B's center of
   //             geometry
   //
   // The vertices of the simplex are reported in body A's frame. The vertices
   // of each body that *contribute* to the simplex are reported in the
   // respective body's frame.
   //
   //    E.g. verts are in body A's frame. vert_a_A is in body A's frame.
   //    vert_b_B is in body B's frame.
   //
   // As is tradition, the Minkowski difference is generated by subtracting all
   // points interior to body B from all interior points of body A.
   //
   //    MD = a - b for all a in body A and all b in body B
   //
   // Vertices and support points are calculated in body A's frame!
   template <typename Transform_T, typename ShapeA_T, typename ShapeB_T>
   gjk_result_t alg(
      const Transform_T & trans_A_to_W,
      const Transform_T & trans_B_to_W,
      const ShapeA_T & shape_a_A,
      const ShapeB_T & shape_b_B
   )
   {
      gjk_result_t result;
      result.intersection = false;
      result.minSimplex.numVerts = 0;

      MinkowskiDiffSupport<
         Transform_T, ShapeA_T, ShapeB_T
      > md_support(trans_A_to_W, trans_B_to_W, shape_a_A, shape_b_B);

      // center_md_W is used to find an initial simplex point even though it
      // isn't technically at the center of the MD hull.
      Vector3 center_md_W = trans_A_to_W.translate - trans_B_to_W.translate;

      // Initialize simplex with one point. Choose support points in the
      // direction of the vector between the bodies' centers of mass.
      gjk_mdVertex_t support_md_W = md_support(-1.f * center_md_W);

      // Initialize the simplex with one point.
      gjk_simplex_t md_simplex;
      md_simplex.numVerts = 1;
      md_simplex.verts[0] = support_md_W.vert;
      md_simplex.bodyAVertIds[0] = support_md_W.bodyAVertId;
      md_simplex.bodyBVertIds[0] = support_md_W.bodyBVertId;
      md_simplex.bodyAVerts[0] = support_md_W.bodyAVert;
      md_simplex.bodyBVerts[0] = support_md_W.bodyBVert;
      md_simplex.minNormBary[0] = 1.0f;
      md_simplex.minNormBary[1] = 0.0f;
      md_simplex.minNormBary[2] = 0.0f;
      md_simplex.minNormBary[3] = 0.0f;

      result.minSimplex = md_simplex;

      geometry::types::pointBaryCoord_t min_norm_md_W;

      unsigned int max_iters = 20;
      for (unsigned int i = 0; i < max_iters; ++i)
      {
         min_norm_md_W = minNormPoint(md_simplex);

         // If the barycentric coordinate has nan's in it, it means that the
         // simplex is degenerate and should be discarded.
         if (min_norm_md_W.bary.hasNan())
         {
            result.intersection = false;
            break;
         }

         if (min_norm_md_W.point.magnitude() < 1e-6f)
         {
            result.intersection = true;
            break;
         }

         // Reduce the current simplex with the minimum simplex.
         md_simplex = minSimplex(min_norm_md_W.bary, md_simplex);

         // Find the support point in the negative direction of the min-norm
         // point.
         support_md_W = md_support(-1.f * min_norm_md_W.point);

         float min_norm_point_extremity = min_norm_md_W.point.dot(
            -1.0f * min_norm_md_W.point
         );
         float support_point_extremity = support_md_W.vert.dot(
            -1.0f * min_norm_md_W.point
         );

         // Terminate when the min_norm_point.dot(-min_norm_point) is at least
         // as extreme as support_point.dot(-min_norm_point).
         if (min_norm_point_extremity >= support_point_extremity)
         {
            result.intersection = false;
            break;
         }

         // If the new vertex is coincident with any other part of the simplex
         // (e.g. is in the tetrahedron, on the triangle, on the segment, or at
         // the same point), then do not modify the simplex.
         if (pointCoincident(support_md_W.vert, md_simplex))
         {
            result.intersection = false;
            break;
         }
         else
         {
            addVertexToSimplex(support_md_W, md_simplex);
         }
      }

      result.minSimplex = md_simplex;

      return result;
   }

}

}

#endif
