#include "constraint_stove.hpp"

namespace oy
{

   ConstraintStove::ConstraintStove(unsigned int max_lifetime)
      : max_lifetime_(max_lifetime)
   { }

   void ConstraintStove::push(
      const HeapMatrix & lambda_dt,
      const graph::Subgraph<trecs::uid_t, oy::types::edgeId_t> & subgraph
   )
   {
      std::unordered_map<std::bitset<96>, running_average_t> average_lambda_dts;

      for (unsigned int i = 0; i < subgraph.size(); ++i)
      {
         const auto & edge = subgraph[i];

         // An offset less than zero indicates that the edge was generated by
         // an equality constraint. Warm-starting equality constraints can lead
         // to explosions - specifically on over-constrained systems.
         if (edge.edgeId.offset < 0)
         {
            continue;
         }

         std::bitset<96> key = calculateStandardKey(edge);

         const auto avg_iter = average_lambda_dts.find(key);
         const float lambda_val = lambda_dt(i, 0);
         if (avg_iter == average_lambda_dts.end())
         {
            average_lambda_dts[key] = running_average_t(lambda_val);
         }
         else
         {
            average_lambda_dts.at(key).update(lambda_val);
         }
      }

      for (const auto & average_lambda_dt : average_lambda_dts)
      {
         const auto standard_stove_iter = standard_stove_.find(
            average_lambda_dt.first
         );

         if (standard_stove_iter == standard_stove_.end())
         {
            standard_stove_[average_lambda_dt.first].val = \
               average_lambda_dt.second.average;
            standard_stove_[average_lambda_dt.first].count = 0;
         }
         else
         {
            standard_stove_.at(average_lambda_dt.first).val = \
               average_lambda_dt.second.average;
            standard_stove_.at(average_lambda_dt.first).count = 0;
         }
      }
   }

   void ConstraintStove::pull(
      HeapMatrix & lambda_dt,
      const graph::Subgraph<trecs::uid_t, oy::types::edgeId_t> & subgraph,
      const float default_val
   ) const
   {
      for (unsigned int i = 0; i < subgraph.size(); ++i)
      {
         const auto & edge = subgraph[i];
         std::bitset<96> key = calculateStandardKey(edge);

         const auto standard_stove_iter = standard_stove_.find(key);

         if (standard_stove_iter != standard_stove_.end())
         {
            lambda_dt(i, 0) = standard_stove_iter->second.val;
         }
         else
         {
            lambda_dt(i, 0) = default_val;
         }
      }
   }

   void ConstraintStove::increment(void)
   {
      for (auto & lifetime_val : standard_stove_)
      {
         ++lifetime_val.second.count;
      }

      prune();
   }

   void ConstraintStove::prune(void)
   {
      auto standard_stove_iter = standard_stove_.begin();
      while (standard_stove_iter != standard_stove_.end())
      {
         if (standard_stove_iter->second.count > max_lifetime_)
         {
            standard_stove_iter = standard_stove_.erase(standard_stove_iter);
         }
         else
         {
            ++standard_stove_iter;
         }
      }
   }

}
